{"ast":null,"code":"export async function hashData(data) {\n  const buffer = typeof data === 'string' ? new TextEncoder().encode(data) : data;\n  const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);\n  const hashArray = Array.from(new Uint8Array(hashBuffer));\n  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n}\n\n/**\r\n * Converts ArrayBuffer ↔ Base64 safely (works with large buffers).\r\n */\nfunction bufferToBase64(buffer) {\n  let binary = '';\n  const bytes = new Uint8Array(buffer);\n  const chunkSize = 0x8000; // 32KB chunks\n  for (let i = 0; i < bytes.length; i += chunkSize) {\n    binary += String.fromCharCode(...bytes.subarray(i, i + chunkSize));\n  }\n  return btoa(binary);\n}\nfunction base64ToBuffer(base64) {\n  const binary = atob(base64);\n  const bytes = new Uint8Array(binary.length);\n  for (let i = 0; i < binary.length; i++) {\n    bytes[i] = binary.charCodeAt(i);\n  }\n  return bytes;\n}\n\n/**\r\n * Derives an AES-GCM encryption key from a password and salt using PBKDF2.\r\n * @param {string} password - The master password.\r\n * @param {Uint8Array} salt - The salt for key derivation.\r\n * @returns {Promise<CryptoKey>} The derived encryption key.\r\n */\nasync function getEncryptionKey(password, salt) {\n  const enc = new TextEncoder();\n  const keyMaterial = await crypto.subtle.importKey('raw', enc.encode(password), {\n    name: 'PBKDF2'\n  }, false, ['deriveKey']);\n  return crypto.subtle.deriveKey({\n    name: 'PBKDF2',\n    salt: salt,\n    iterations: 100000,\n    hash: 'SHA-256'\n  }, keyMaterial, {\n    name: 'AES-GCM',\n    length: 256\n  }, true, ['encrypt', 'decrypt']);\n}\n\n/**\r\n * Encrypts a data object using a master password.\r\n * @param {object} dataObject - The JSON object to encrypt.\r\n * @param {string} password - The master password.\r\n * @returns {Promise<object>} An object containing the encrypted data and necessary metadata.\r\n */\nexport async function encryptData(dataObject, password) {\n  const salt = crypto.getRandomValues(new Uint8Array(16));\n  const iv = crypto.getRandomValues(new Uint8Array(12));\n  const key = await getEncryptionKey(password, salt);\n  const dataString = JSON.stringify(dataObject);\n  const encodedData = new TextEncoder().encode(dataString);\n  const encryptedContent = await crypto.subtle.encrypt({\n    name: 'AES-GCM',\n    iv: iv\n  }, key, encodedData);\n  return {\n    encryptedPackage: {\n      salt: bufferToBase64(salt),\n      iv: bufferToBase64(iv),\n      encryptedData: bufferToBase64(encryptedContent)\n    }\n  };\n}\n\n/**\r\n * Decrypts an encrypted package using the master password.\r\n * @param {object} encryptedPackage - The object containing encrypted data and metadata from the server.\r\n * @param {string} password - The master password.\r\n * @returns {Promise<object|null>} The decrypted JSON object, or null if decryption fails.\r\n */\nexport async function decryptData(encryptedPackage, password) {\n  try {\n    const salt = base64ToBuffer(encryptedPackage.salt);\n    const iv = base64ToBuffer(encryptedPackage.iv);\n    const encryptedData = base64ToBuffer(encryptedPackage.encryptedData);\n    const key = await getEncryptionKey(password, salt);\n    const decryptedContent = await crypto.subtle.decrypt({\n      name: 'AES-GCM',\n      iv: iv\n    }, key, encryptedData);\n    const decodedData = new TextDecoder().decode(decryptedContent);\n    return JSON.parse(decodedData);\n  } catch (error) {\n    console.error(\"Decryption failed:\", error);\n    console.warn(\"Check that password, salt, and iv are identical to those used during encryption.\");\n    return null; // Indicates wrong password or corrupted data\n  }\n}\n\n/* ------------------------------------------------------------------\r\n   SELF-TEST HARNESS\r\n   Encrypts and then decrypts { hello: \"world\" } with password \"test123\"\r\n   to prove encryption/decryption works in isolation.\r\n-------------------------------------------------------------------*/\n(async () => {\n  const testData = {\n    hello: \"world\"\n  };\n  const password = \"test123\";\n  console.log(\"---- SELF TEST START ----\");\n  const {\n    encryptedPackage\n  } = await encryptData(testData, password);\n  console.log(\"Encrypted package:\", encryptedPackage);\n  const decrypted = await decryptData(encryptedPackage, password);\n  console.log(\"Decrypted result:\", decrypted);\n  console.log(\"---- SELF TEST END ----\");\n})();","map":{"version":3,"names":["hashData","data","buffer","TextEncoder","encode","hashBuffer","crypto","subtle","digest","hashArray","Array","from","Uint8Array","map","b","toString","padStart","join","bufferToBase64","binary","bytes","chunkSize","i","length","String","fromCharCode","subarray","btoa","base64ToBuffer","base64","atob","charCodeAt","getEncryptionKey","password","salt","enc","keyMaterial","importKey","name","deriveKey","iterations","hash","encryptData","dataObject","getRandomValues","iv","key","dataString","JSON","stringify","encodedData","encryptedContent","encrypt","encryptedPackage","encryptedData","decryptData","decryptedContent","decrypt","decodedData","TextDecoder","decode","parse","error","console","warn","testData","hello","log","decrypted"],"sources":["C:/Users/gul4b1/Desktop/cv/image-password-vault/client/src/crypto/crypto.js"],"sourcesContent":["export async function hashData(data) {\r\n    const buffer = typeof data === 'string' ? new TextEncoder().encode(data) : data;\r\n    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);\r\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\r\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\r\n}\r\n\r\n/**\r\n * Converts ArrayBuffer ↔ Base64 safely (works with large buffers).\r\n */\r\nfunction bufferToBase64(buffer) {\r\n    let binary = '';\r\n    const bytes = new Uint8Array(buffer);\r\n    const chunkSize = 0x8000; // 32KB chunks\r\n    for (let i = 0; i < bytes.length; i += chunkSize) {\r\n        binary += String.fromCharCode(...bytes.subarray(i, i + chunkSize));\r\n    }\r\n    return btoa(binary);\r\n}\r\n\r\nfunction base64ToBuffer(base64) {\r\n    const binary = atob(base64);\r\n    const bytes = new Uint8Array(binary.length);\r\n    for (let i = 0; i < binary.length; i++) {\r\n        bytes[i] = binary.charCodeAt(i);\r\n    }\r\n    return bytes;\r\n}\r\n\r\n/**\r\n * Derives an AES-GCM encryption key from a password and salt using PBKDF2.\r\n * @param {string} password - The master password.\r\n * @param {Uint8Array} salt - The salt for key derivation.\r\n * @returns {Promise<CryptoKey>} The derived encryption key.\r\n */\r\nasync function getEncryptionKey(password, salt) {\r\n    const enc = new TextEncoder();\r\n    const keyMaterial = await crypto.subtle.importKey(\r\n        'raw',\r\n        enc.encode(password),\r\n        { name: 'PBKDF2' },\r\n        false,\r\n        ['deriveKey']\r\n    );\r\n    return crypto.subtle.deriveKey(\r\n        {\r\n            name: 'PBKDF2',\r\n            salt: salt,\r\n            iterations: 100000,\r\n            hash: 'SHA-256'\r\n        },\r\n        keyMaterial,\r\n        { name: 'AES-GCM', length: 256 },\r\n        true,\r\n        ['encrypt', 'decrypt']\r\n    );\r\n}\r\n\r\n/**\r\n * Encrypts a data object using a master password.\r\n * @param {object} dataObject - The JSON object to encrypt.\r\n * @param {string} password - The master password.\r\n * @returns {Promise<object>} An object containing the encrypted data and necessary metadata.\r\n */\r\nexport async function encryptData(dataObject, password) {\r\n    const salt = crypto.getRandomValues(new Uint8Array(16));\r\n    const iv = crypto.getRandomValues(new Uint8Array(12));\r\n    const key = await getEncryptionKey(password, salt);\r\n    const dataString = JSON.stringify(dataObject);\r\n    const encodedData = new TextEncoder().encode(dataString);\r\n    \r\n    const encryptedContent = await crypto.subtle.encrypt(\r\n        { name: 'AES-GCM', iv: iv },\r\n        key,\r\n        encodedData\r\n    );\r\n\r\n    return {\r\n        encryptedPackage: {\r\n            salt: bufferToBase64(salt),\r\n            iv: bufferToBase64(iv),\r\n            encryptedData: bufferToBase64(encryptedContent)\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * Decrypts an encrypted package using the master password.\r\n * @param {object} encryptedPackage - The object containing encrypted data and metadata from the server.\r\n * @param {string} password - The master password.\r\n * @returns {Promise<object|null>} The decrypted JSON object, or null if decryption fails.\r\n */\r\nexport async function decryptData(encryptedPackage, password) {\r\n    try {\r\n        const salt = base64ToBuffer(encryptedPackage.salt);\r\n        const iv = base64ToBuffer(encryptedPackage.iv);\r\n        const encryptedData = base64ToBuffer(encryptedPackage.encryptedData);\r\n\r\n        const key = await getEncryptionKey(password, salt);\r\n\r\n        const decryptedContent = await crypto.subtle.decrypt(\r\n            { name: 'AES-GCM', iv: iv },\r\n            key,\r\n            encryptedData\r\n        );\r\n\r\n        const decodedData = new TextDecoder().decode(decryptedContent);\r\n        return JSON.parse(decodedData);\r\n    } catch (error) {\r\n        console.error(\"Decryption failed:\", error);\r\n        console.warn(\"Check that password, salt, and iv are identical to those used during encryption.\");\r\n        return null; // Indicates wrong password or corrupted data\r\n    }\r\n}\r\n\r\n/* ------------------------------------------------------------------\r\n   SELF-TEST HARNESS\r\n   Encrypts and then decrypts { hello: \"world\" } with password \"test123\"\r\n   to prove encryption/decryption works in isolation.\r\n-------------------------------------------------------------------*/\r\n(async () => {\r\n    const testData = { hello: \"world\" };\r\n    const password = \"test123\";\r\n\r\n    console.log(\"---- SELF TEST START ----\");\r\n    const { encryptedPackage } = await encryptData(testData, password);\r\n    console.log(\"Encrypted package:\", encryptedPackage);\r\n\r\n    const decrypted = await decryptData(encryptedPackage, password);\r\n    console.log(\"Decrypted result:\", decrypted);\r\n    console.log(\"---- SELF TEST END ----\");\r\n})();\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}